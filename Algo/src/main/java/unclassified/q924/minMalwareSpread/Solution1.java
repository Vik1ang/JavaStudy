package unclassified.q924.minMalwareSpread;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class Solution1 {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        UnionFind unionFind = new UnionFind(n);

        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                if (graph[i][j] == 1) {
                    unionFind.union(i, j);
                }
            }
        }

        Arrays.sort(initial);

        // 联通点的计数
        int[] count = new int[n];
        for (int i = 0; i < n; i++) {
            count[unionFind.find(i)]++;
        }

        int res = Integer.MAX_VALUE;
        int size = -1;

        for (int i : initial) {
            int node = unionFind.find(i);
            if (count[node] == 1) {
                int count1 = unionFind.getSize(node);
                if ((count1 > size) || (count1 == size && node < res)) {
                    size = count1;
                    res = i;
                }
            }
        }

        if (res == Integer.MAX_VALUE) {
            for (int i : initial) {
                res = Math.min(res, i);
            }
        }

        return res;

    }
}

class UnionFind {
    private int count;
    private int[] parent;
    private int[] size;

    public UnionFind(int n) {
        count = n;
        parent = new int[n];
        size = new int[n];

        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);

        if (rootP != rootQ) {
            parent[rootP] = rootQ;
            count--;
        }


    }

    public int find(int x) {
        if (parent[x] != x) {
            return find(parent[x]);
        }
        return x;
    }

    public int getSize(int x) {
        return size[find(x)];
    }
}